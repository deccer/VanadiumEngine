#version 450 core

#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 0, binding = 0, rgba32f) uniform writeonly image2D transmittanceLUT;

const float pi = 3.14159265359;
const float pi3 = pi * pi * pi;
const uint nSamples = 40;

layout(push_constant) uniform Constants {
	ivec4 lutSize;
	vec4 betaExtinctionZeroMie;
	vec4 betaExtinctionZeroRayleigh;
	vec4 absorptionZeroOzone;
	float heightScaleRayleigh;
	float heightScaleMie;
	float layerHeightOzone;
	float layer0ConstantFactorOzone;
	float layer1ConstantFactorOzone;
	float heightRangeOzone;
	float maxHeight;
	float groundRadius;
};

void uvToHeightCosTheta(vec2 uv, out float height, out float cosTheta) {
	float x_mu = uv.x;
	float x_r = uv.y;

	float H = sqrt((groundRadius + maxHeight) * (groundRadius + maxHeight) - groundRadius * groundRadius);
	float rho = H * x_r;
	height = sqrt(rho * rho + groundRadius * groundRadius);

	float d_min = (groundRadius + maxHeight) - height;
	float d_max = rho + H;
	float d = d_min + x_mu * (d_max - d_min);
	cosTheta = d == 0.0 ? 1.0f : (H * H - rho * rho - d * d) / (2.0 * height * d);
	cosTheta = clamp(cosTheta, -1.0, 1.0);
}

#include "functions/transmittance-compute.glsl"

void main() {
	ivec2 imageCoordinate = ivec2(gl_LocalInvocationID.xy) + ivec2(gl_WorkGroupID.xy) * ivec2(gl_WorkGroupSize.xy);
	vec2 normalizedCoordinates = imageCoordinate / vec2(lutSize.xy);

	float startHeight, cosTheta;
	uvToHeightCosTheta(normalizedCoordinates, startHeight, cosTheta);
	vec2 direction = vec2(sqrt(1.0f - cosTheta * cosTheta), cosTheta);

	float endPosT = nearestDistanceToSphere(startHeight, direction, groundRadius);
	float tGround = nearestDistanceToSphere(startHeight, direction, groundRadius + maxHeight);
	
	if(tGround > 0.0f)
		endPosT = min(endPosT, tGround);

	if(imageCoordinate.x < lutSize.x && imageCoordinate.y < lutSize.y) {
		imageStore(transmittanceLUT, imageCoordinate, vec4(calcTransmittance(vec2(0.0f, startHeight), direction, endPosT / nSamples), 1.0f));
	}
}