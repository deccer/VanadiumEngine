#version 450 core

layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 0, binding = 0, rgba32f) uniform writeonly image2D transmittanceLUT;

const float pi = 3.14159265359;
const float pi3 = pi * pi * pi;
const uint nSamples = 40;

layout(push_constant) uniform Constants {
	ivec2 lutSize;
	vec3 betaExtinctionZeroMie;
	float heightScaleRayleigh;
	float heightScaleMie;
	float iorAir;
	float molecularDensity;
	float maxHeight;
	float groundRadius;
};

void uvToHeightCosTheta(vec2 uv, out float height, out float cosTheta) {
	float x_mu = uv.x;
	float x_r = uv.y;

	float H = sqrt((groundRadius + maxHeight) * (groundRadius + maxHeight) - groundRadius * groundRadius);
	float rho = H * x_r;
	height = sqrt(rho * rho + groundRadius * groundRadius);

	float d_min = (groundRadius + maxHeight) - height;
	float d_max = rho + H;
	float d = d_min + x_mu * (d_max - d_min);
	cosTheta = d == 0.0 ? 1.0f : (H * H - rho * rho - d * d) / (2.0 * height * d);
	cosTheta = clamp(cosTheta, -1.0, 1.0);
}

float opticalLengthToX0(vec2 x, vec2 direction, float endPosT, float heightScale) {
	float deltaT = endPosT / nSamples;
	vec2 currentPos = vec2(0.0f, x.y);
	
	float result = 0.0f;

	return result;
}

vec3 betaExtinctionRayleigh(float height) {
	float diffIorAir = (iorAir * iorAir - 1);
	vec3 lambda = vec3(680, 550, 440) * 1e-9;
	vec3 lambda4 = lambda * lambda * lambda * lambda;
	return 8 * pi3 * diffIorAir * diffIorAir / (3 * molecularDensity * lambda4) * exp(-(height - groundRadius) / heightScaleRayleigh);
}

vec3 betaExtinctionMie(float height) {
	return /*betaExtinctionZeroMie **/ exp(-(height - groundRadius) / heightScaleMie).xxx;
}

float nearestDistanceToSphere(float startHeight, vec2 direction, float radius) {
	vec2 centerToOrigin = vec2(0.0f, -startHeight);

	float dirDotCTO = dot(direction, centerToOrigin);

	float discriminant = pow(2 * dirDotCTO, 2) - 4.0f * (dot(centerToOrigin, centerToOrigin) - radius * radius);

	if(discriminant >= 0.0) {
		float q;
		if(dirDotCTO > 0.0f) {
			q = -1.0f * dirDotCTO - sqrt(discriminant);
		}
		else {
			q = -1.0f * dirDotCTO + sqrt(discriminant);
		}
		float q1 = (dot(centerToOrigin, centerToOrigin) - radius * radius) / q;
		float result;
		if(q < 0.0f) {
			if(q1 < 0.0f)
				return max(q, q1);
			else
				return q1;
		}
		else if(q1 < 0.0f) {
			return q;
		}
		else {
			return min(q, q1);
		}
	}
}

void main() {
	ivec2 imageCoordinate = ivec2(gl_LocalInvocationID.xy) + ivec2(gl_WorkGroupID.xy) * ivec2(gl_WorkGroupSize.xy);
	vec2 normalizedCoordinates = imageCoordinate / vec2(lutSize);

	float startHeight, cosTheta;
	uvToHeightCosTheta(normalizedCoordinates, startHeight, cosTheta);
	vec2 direction = vec2(sqrt(1.0f - cosTheta * cosTheta), cosTheta);

	float endPosT = 1.0f;
	float tTop = nearestDistanceToSphere(startHeight, direction, groundRadius + maxHeight);
	float tGround = nearestDistanceToSphere(startHeight, direction, groundRadius);
	
	if(tGround <= 0.0f)
		endPosT = tTop;
	else
		endPosT = min(tTop, tGround);

	vec3 result = vec3(0.0f);
	vec2 currentPos = vec2(0.0f, startHeight);
	float deltaT = endPosT / nSamples;
	for(uint i = 0; i < nSamples; ++i, currentPos += direction * deltaT) {
		result += (/*betaExtinctionRayleigh(length(currentPos)) +*/ betaExtinctionMie(length(currentPos))) * deltaT;
	}
	result = endPosT.xxx;//exp(-result);

	if(imageCoordinate.x < lutSize.x && imageCoordinate.y < lutSize.y) {
		imageStore(transmittanceLUT, imageCoordinate, vec4(result, 1.0f));
	}
}